function synthetic_data (n, SNR)
% generates the pre-specified data sets with n elements and that SNR
seed=0;   
randn('state',seed);
rand('state',seed);

x_max = 2;
%data_folder = 'F:/Computer Science/Part III Research Project/Data/syntheticdata/';
data_folder = '/auto/homes/nm480/Documents/Part III Project/Data/syntheticdata/';

% SE1 * SE2
covs{1} = {@covProd,{...
                    {@covMask, {[1 0 0 0], {@covSEiso}}}, ...
                    {@covMask, {[0 1 0 0], {@covSEiso}}} ...
                    }...
                    };
cov_params{1} = [0 4 -2 4];
dims{1} = 4;
names{1} = 'SE1_prod_SE2.mat';


% SE1 + SE2
covs{2} = {@covSum, {...
                    {@covMask, {[1 0 0 0], {@covSEiso}}}, ...
                    {@covMask, {[0 1 0 0], {@covSEiso}}} ...
                    } ...
                    };
cov_params{2} = [0 7 -2 7];
dims{2} = 4;
names{2} = 'SE1_plus_SE2.mat';

% SE1 in 2D
covs{7} =  {@covMask, {[1 0], {@covSEiso}}};
cov_params{7} = [0 0];
dims{7} = 2;
names{7} = 'SE1in2D';


covs{3} = {@covSum ,{...
                    {@covMask, {[1 0 0 0], @covSEiso  }}, ...
                    {@covMask, {[0 0 1 0], {@covSEiso}}},... 
                    {@covMask, {[0 0 0 1], @covSEiso}} ...
                    }...
                    };
cov_params{3} = [0 0 -1 0 -2 0];
dims{3} = 4;
names{3} = 'SE1_plus_SE3_plus_SE4.mat';


% (SE1 + SE2) * (SE3 + SE4), 4 dimensions, all same lengthscales

covs{4} = {@covProd,{...
                    {@covSum, {...
                               {@covMask, {[1 0 0 0], {@covSEiso}}},... 
                               {@covMask, {[0 1 0 0], {@covSEiso}}}...
                               }...
                    },...
                    {@covSum, {...
                               {@covMask, {[0 0 1 0], {@covSEiso}}},... 
                               {@covMask, {[0 0 0 1], {@covSEiso}}}...
                               }...
                    }...
                    }...
                    };
                
cov_params{4} = [-1 0 -1 0 -1 0 -1 0];
dims{4} = 4;
names{4} = '(SE1_plus_SE2)_prod_(SE3_plus_SE4).mat';

% SEiso + RQiso..
covs{5} = {@covSum, {...
                    {@covSEiso}, ...
                    {@covRQiso} ...
                    } ...
                    };
cov_params{5} = [0 0 -1 0 -2];
dims{5} = 1;
names{5} = 'SE1_plus_RQ1.mat';

% SE1 * SE2 + SE2 * SE3, 4 dimensions
covs{6} = {@covSum,{...
                    {@covProd, {...
                               {@covMask, {[1 0 0 0], {@covSEiso}}},... 
                               {@covMask, {[0 1 0 0], {@covSEiso}}}...
                               }...
                    },...
                    {@covProd, {...
                               {@covMask, {[0 1 0 0], {@covSEiso}}},... 
                               {@covMask, {[0 0 1 0], {@covSEiso}}}...
                               }...
                    }...
                    }...
                    };
cov_params{6} = [-1 0 0 0 -1 0 -1 0];
dims{6} = 4;
names{6} = 'SE1_prod_SE2_plus_SE2_prod_SE3.mat';


for i = 1:length(covs)
    
    X = (rand(2*n,dims{i})-0.5)*2*x_max;
    K = feval(covs{i}{:}, cov_params{i}, X);
    K = K + 1e-4*eye(2*n);
    y = chol(K)' * randn(2*n,1);
    y = y - mean(y); % 0-center
    y = y / std(y);  % normalise
    y = y + randn(size(y)) * (1/SNR^0.5); % SNR ratio of 10! working at standard deviation level (ppl usually use variances, so actual is * 10). 
    y = pullClasses(y, 0);
    
    y = y';
    
    X_trn = X(1:n, : );  
    y_trn = y(1:n);
    X_tst = X((n+1):(2*n), :); 
    y_tst = y( (n+1): (2*n) );
    
       
    save([data_folder names{i}], 'X_trn', 'y_trn', 'X_tst', 'y_tst');

end

end

% feed noise-to signal as 0.01 1 and 100

% 1, 10, 100 to be tried.